<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title> COHLIT - Rutgers University </title>
	<link rel="stylesheet" type="text/css" href="main.css"></link>
</head>
<body>
<div id="container"></div>

	<script type="text/javascript" src="./js/three.js"></script>
	<script type="text/javascript" src="./js/StereoEffect.js"></script>
	<script type="text/javascript" src="./js/Detector.js"></script>
	<script type="text/javascript" src="./js/DeviceOrientationControls.js"></script>
	<script type="text/javascript" src="./js/OrbitControls.js"></script>
	<script>
		if( !Detector.webgl) {
			Detector.addGetWebGLMessage();
		}
		else {
			var clock, scene, camera, renderer, container;
			var effect, controls;
			var geometry, material, cube, cube2;

			var create = function() {
				clock = new THREE.Clock();

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(0xffffff, 1);
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(window.innerWidth, window.innerHeight);
				container = document.getElementById("container");
				container.appendChild(renderer.domElement);

				effect = new THREE.StereoEffect(renderer);
				//effect.eyeSeparation = 10;
				effect.setSize(window.innerWidth, window.innerHeight);

				controls =  new THREE.OrbitControls(camera, render.domElement);
				controls.rotateUp(Math.PI/4);
				controls.target.set(
					camera.position.x + 0.1,
					camera.position.y,
					camera.position.z
				);
				controls.noZoom = true;
				controls.noPan = true;

				var setOrientationControls = function(e) {
					if(!e.alpha) {
						return;
					}

					controls = new THREE.DeviceOrientationControls(camera, true);
					controls.connect();
					controls.update();

					renderer.domElement.addEventListener('click', fullscreen, false);
					window.removeEventListener('deviceorientation', setOrientationControls, true);
				}
				window.addEventListener('deviceorientation', setOrientationControls, true);

				geometry = new THREE.BoxGeometry(2,2,2);
				material = new THREE.MeshBasicMaterial({color: 0x00ffaa});
				cube = new THREE.Mesh(geometry, material);
				scene.add(cube);
				cube.position.x = 2;
				cube.position.z = -10;

				cube2 = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0x8888cc}));
				scene.add(cube2);
				cube2.position.x = -2;
				cube2.position.z = -10;


			}
			
			var fullscreen = function() {
				if(container.requestFullscreen) {
					container.requestFullscreen();
				}
				else if(container.msRequestFullscreen) {
					container.msRequestFullscreen();
				}
				else if (container.mozRequestFullScreen) {
					container.mozRequestFullScreen();
				}
				else if(container.webkitRequestFullscreen) {
					container.webkitRequestFullscreen();
				}
			}

			var resize = function() {
				camera.aspect = container.offsetWidth/container.offsetHeight;
				camera.updateProjectionMatrix();

				//renderer.setSize(container.offsetWidth, container.offsetHeight);
				//effect.setSize(container.offsetWidth, container.offsetHeight);
			}

			var update = function(dt) {
				resize();

				camera.updateProjectionMatrix();

				controls.update(dt);
			}
			
			var render = function() {
				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;

				cube2.rotation.x += 0.01;
				cube2.rotation.y += 0.01;

				effect.render(scene, camera);
			}

			var animate = function(t) {
				requestAnimationFrame(animate);

				update(clock.getDelta());	
				render(clock.getDelta());
			}

			create();
			animate();
		}
	</script>
</body>
</html>
